package com.example.demo.logging;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.Duration;

/**
 * Aspect for performance monitoring and detailed method execution logging.
 * 
 * <p>This aspect automatically logs method entry, exit, execution time, and performance
 * metrics for all service layer methods. It's specifically designed to work with
 * reactive types (Mono and Flux) to provide accurate timing information.</p>
 * 
 * <p>Performance Metrics Tracked:</p>
 * <ul>
 *   <li>Method execution time</li>
 *   <li>Parameter values (for debugging)</li>
 *   <li>Return value types and counts</li>
 *   <li>Exception details</li>
 * </ul>
 * 
 * @author Generated by GitHub Copilot
 * @version 1.0
 * @since 1.0
 */
@Aspect
@Component
public class PerformanceLoggingAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(PerformanceLoggingAspect.class);
    
    /**
     * Around advice for all service layer methods.
     * 
     * <p>This method intercepts all method calls in the service package and logs
     * performance metrics. It handles both reactive and non-reactive return types.</p>
     * 
     * @param joinPoint the method execution context
     * @return the method result
     * @throws Throwable if the intercepted method throws an exception
     */
    @Around("execution(* com.example.demo.service..*(..))")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();
        long startTime = System.currentTimeMillis();
        
        // Log method entry
        if (logger.isDebugEnabled()) {
            Object[] args = joinPoint.getArgs();
            StringBuilder argsString = new StringBuilder();
            for (int i = 0; i < args.length; i++) {
                if (i > 0) argsString.append(", ");
                argsString.append(args[i] != null ? args[i].toString() : "null");
            }
            logger.debug("[PERF] Method Entry: {} with args: [{}]", methodName, argsString);
        }
        
        try {
            Object result = joinPoint.proceed();
            
            // Handle reactive types
            if (result instanceof Mono) {
                return handleMono((Mono<?>) result, methodName, startTime);
            } else if (result instanceof Flux) {
                return handleFlux((Flux<?>) result, methodName, startTime);
            } else {
                // Handle non-reactive types
                long executionTime = System.currentTimeMillis() - startTime;
                logger.info("[PERF] Method Exit: {} executed in {}ms", methodName, executionTime);
                return result;
            }
        } catch (Exception e) {
            long executionTime = System.currentTimeMillis() - startTime;
            logger.error("[PERF] Method Error: {} failed after {}ms with error: {}", 
                methodName, executionTime, e.getMessage());
            throw e;
        }
    }
    
    /**
     * Handles Mono return types with performance logging.
     * 
     * @param mono the Mono to enhance with logging
     * @param methodName the name of the method
     * @param startTime the method start time
     * @return the enhanced Mono with logging
     */
    private Mono<?> handleMono(Mono<?> mono, String methodName, long startTime) {
        return mono
                .doOnSubscribe(subscription -> {
                    if (logger.isTraceEnabled()) {
                        logger.trace("[PERF] Mono Subscribed: {} started processing", methodName);
                    }
                })
                .doOnNext(item -> {
                    long executionTime = System.currentTimeMillis() - startTime;
                    logger.info("[PERF] Mono Success: {} completed in {}ms with result", 
                        methodName, executionTime);
                    if (logger.isTraceEnabled()) {
                        logger.trace("[PERF] Mono Result: {} returned: {}", methodName, item);
                    }
                })
                .doOnError(error -> {
                    long executionTime = System.currentTimeMillis() - startTime;
                    logger.error("[PERF] Mono Error: {} failed after {}ms with error: {}", 
                        methodName, executionTime, error.getMessage());
                })
                .doOnTerminate(() -> {
                    if (logger.isTraceEnabled()) {
                        logger.trace("[PERF] Mono Terminated: {} stream ended", methodName);
                    }
                });
    }
    
    /**
     * Handles Flux return types with performance logging.
     * 
     * @param flux the Flux to enhance with logging
     * @param methodName the name of the method
     * @param startTime the method start time
     * @return the enhanced Flux with logging
     */
    private Flux<?> handleFlux(Flux<?> flux, String methodName, long startTime) {
        return flux
                .doOnSubscribe(subscription -> {
                    if (logger.isTraceEnabled()) {
                        logger.trace("[PERF] Flux Subscribed: {} started processing", methodName);
                    }
                })
                .doOnNext(item -> {
                    if (logger.isTraceEnabled()) {
                        logger.trace("[PERF] Flux Item: {} emitted item: {}", methodName, item);
                    }
                })
                .doOnComplete(() -> {
                    long executionTime = System.currentTimeMillis() - startTime;
                    logger.info("[PERF] Flux Complete: {} completed in {}ms", methodName, executionTime);
                })
                .doOnError(error -> {
                    long executionTime = System.currentTimeMillis() - startTime;
                    logger.error("[PERF] Flux Error: {} failed after {}ms with error: {}", 
                        methodName, executionTime, error.getMessage());
                })
                .doOnTerminate(() -> {
                    if (logger.isTraceEnabled()) {
                        logger.trace("[PERF] Flux Terminated: {} stream ended", methodName);
                    }
                });
    }
    
    /**
     * Around advice for controller layer methods to log HTTP request/response timing.
     * 
     * @param joinPoint the method execution context
     * @return the method result
     * @throws Throwable if the intercepted method throws an exception
     */
    @Around("execution(* com.example.demo.controller..*(..))")
    public Object logControllerExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();
        long startTime = System.currentTimeMillis();
        
        logger.info("[HTTP] Request started: {}", methodName);
        
        try {
            Object result = joinPoint.proceed();
            
            // Handle reactive types for HTTP responses
            if (result instanceof Mono) {
                return ((Mono<?>) result)
                        .doOnNext(response -> {
                            long executionTime = System.currentTimeMillis() - startTime;
                            logger.info("[HTTP] Request completed: {} in {}ms", methodName, executionTime);
                        })
                        .doOnError(error -> {
                            long executionTime = System.currentTimeMillis() - startTime;
                            logger.error("[HTTP] Request failed: {} in {}ms - Error: {}", 
                                methodName, executionTime, error.getMessage());
                        });
            } else if (result instanceof Flux) {
                return ((Flux<?>) result)
                        .doOnComplete(() -> {
                            long executionTime = System.currentTimeMillis() - startTime;
                            logger.info("[HTTP] Request completed: {} in {}ms", methodName, executionTime);
                        })
                        .doOnError(error -> {
                            long executionTime = System.currentTimeMillis() - startTime;
                            logger.error("[HTTP] Request failed: {} in {}ms - Error: {}", 
                                methodName, executionTime, error.getMessage());
                        });
            } else {
                long executionTime = System.currentTimeMillis() - startTime;
                logger.info("[HTTP] Request completed: {} in {}ms", methodName, executionTime);
                return result;
            }
        } catch (Exception e) {
            long executionTime = System.currentTimeMillis() - startTime;
            logger.error("[HTTP] Request failed: {} in {}ms - Error: {}", 
                methodName, executionTime, e.getMessage());
            throw e;
        }
    }
}
