package com.example.demo.service;

import com.example.demo.logging.AuditLogger;
import com.example.demo.model.User;
import com.example.demo.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.UUID;

/**
 * Service layer for User operations in a Spring WebFlux application.
 * 
 * <p>This service provides business logic for user management operations.
 * It acts as an intermediary between the controller layer and the repository layer,
 * handling business rules, validation, and data transformation.</p>
 * 
 * <p>Key responsibilities:</p>
 * <ul>
 *   <li>Business logic enforcement</li>
 *   <li>Data validation and transformation</li>
 *   <li>Error handling and custom exceptions</li>
 *   <li>Coordination between multiple repositories if needed</li>
 * </ul>
 * 
 * @author Generated by GitHub Copilot
 * @version 1.0
 * @since 1.0
 */
@Service
public class UserService {
    
    private static final String CLASS_NAME = "UserService";
    
    private final UserRepository userRepository;
    private final AuditLogger auditLogger;
    
    /**
     * Constructor for dependency injection.
     * 
     * @param userRepository the user repository to be injected
     * @param auditLogger the audit logger for tracking operations
     */
    @Autowired
    public UserService(UserRepository userRepository, AuditLogger auditLogger) {
        this.userRepository = userRepository;
        this.auditLogger = auditLogger;
    }
    
    /**
     * Creates a new user with auto-generated ID.
     * 
     * <p>This method generates a unique ID for the user and validates
     * that the email address is not already in use.</p>
     * 
     * @param firstName the user's first name, must not be null or empty
     * @param lastName the user's last name, must not be null or empty
     * @param email the user's email address, must not be null or empty
     * @return a {@link Mono} emitting the created user
     * @throws IllegalArgumentException if email already exists
     */
    public Mono<User> createUser(String firstName, String lastName, String email) {
        long startTime = System.currentTimeMillis();
        auditLogger.logMethodEntry(CLASS_NAME, "createUser", firstName, lastName, email);
        
        return userRepository.existsByEmail(email)
                .flatMap(exists -> {
                    if (Boolean.TRUE.equals(exists)) {
                        auditLogger.logDuplicateEmail(email, AuditLogger.OP_CREATE);
                        return Mono.error(new IllegalArgumentException("Email already exists: " + email));
                    }
                    String id = UUID.randomUUID().toString();
                    User newUser = new User(id, firstName, lastName, email);
                    return userRepository.save(newUser);
                })
                .doOnSuccess(user -> {
                    auditLogger.logUserCreated(user);
                    auditLogger.logMethodExit(CLASS_NAME, "createUser", System.currentTimeMillis() - startTime);
                })
                .doOnError(error -> {
                    auditLogger.logUserCreationFailed(email, error.getMessage());
                    auditLogger.logError(AuditLogger.OP_CREATE, error, 
                        String.format("Failed to create user: %s %s (%s)", firstName, lastName, email));
                });
    }
    
    /**
     * Retrieves a user by their unique identifier.
     * 
     * @param id the user ID to search for
     * @return a {@link Mono} emitting the user if found, or empty if not found
     */
    public Mono<User> getUserById(String id) {
        long startTime = System.currentTimeMillis();
        auditLogger.logMethodEntry(CLASS_NAME, "getUserById", id);
        
        return userRepository.findById(id)
                .doOnNext(user -> {
                    auditLogger.logUserRetrieved(user.getId(), "BY_ID");
                    auditLogger.logMethodExit(CLASS_NAME, "getUserById", System.currentTimeMillis() - startTime);
                })
                .doOnTerminate(() -> {
                    // This will be called whether the Mono is empty or has a value
                    if (System.currentTimeMillis() - startTime > 0) { // Only log if we haven't logged yet
                        auditLogger.logMethodExit(CLASS_NAME, "getUserById", System.currentTimeMillis() - startTime);
                    }
                })
                .switchIfEmpty(Mono.defer(() -> {
                    auditLogger.logUserNotFound(id, "BY_ID");
                    return Mono.empty();
                }));
    }
    
    /**
     * Retrieves a user by their email address.
     * 
     * @param email the email address to search for
     * @return a {@link Mono} emitting the user if found, or empty if not found
     */
    public Mono<User> getUserByEmail(String email) {
        return userRepository.findByEmail(email);
    }
    
    /**
     * Retrieves all users from the repository.
     * 
     * @return a {@link Flux} emitting all users
     */
    public Flux<User> getAllUsers() {
        long startTime = System.currentTimeMillis();
        auditLogger.logMethodEntry(CLASS_NAME, "getAllUsers");
        
        return userRepository.findAll()
                .collectList()
                .doOnNext(users -> {
                    auditLogger.logListAllUsers(users.size());
                    auditLogger.logMethodExit(CLASS_NAME, "getAllUsers", System.currentTimeMillis() - startTime);
                })
                .flatMapMany(Flux::fromIterable);
    }
    
    /**
     * Searches for users by name (first name or last name containing the search term).
     * 
     * @param searchTerm the term to search for in user names
     * @return a {@link Flux} emitting matching users
     */
    public Flux<User> searchUsersByName(String searchTerm) {
        long startTime = System.currentTimeMillis();
        auditLogger.logMethodEntry(CLASS_NAME, "searchUsersByName", searchTerm);
        
        return userRepository.findByNameContaining(searchTerm)
                .collectList()
                .doOnNext(users -> {
                    auditLogger.logUserSearch(searchTerm, users.size());
                    auditLogger.logMethodExit(CLASS_NAME, "searchUsersByName", System.currentTimeMillis() - startTime);
                })
                .flatMapMany(Flux::fromIterable);
    }
    
    /**
     * Updates an existing user's information.
     * 
     * <p>This method validates that the user exists and that the new email
     * (if different from current) is not already in use by another user.</p>
     * 
     * @param id the ID of the user to update
     * @param firstName the new first name
     * @param lastName the new last name
     * @param email the new email address
     * @return a {@link Mono} emitting the updated user
     * @throws IllegalArgumentException if user not found or email conflict
     */
    public Mono<User> updateUser(String id, String firstName, String lastName, String email) {
        return userRepository.findById(id)
                .switchIfEmpty(Mono.error(new IllegalArgumentException("User not found with id: " + id)))
                .flatMap(existingUser -> {
                    // If email is changing, check if new email is already in use
                    if (!email.equals(existingUser.getEmail())) {
                        return userRepository.existsByEmail(email)
                                .flatMap(emailExists -> {
                                    if (Boolean.TRUE.equals(emailExists)) {
                                        return Mono.error(new IllegalArgumentException("Email already exists: " + email));
                                    }
                                    User updatedUser = existingUser.withUpdatedInfo(firstName, lastName, email);
                                    return userRepository.save(updatedUser);
                                });
                    } else {
                        // Email is not changing, proceed with update
                        User updatedUser = existingUser.withUpdatedInfo(firstName, lastName, email);
                        return userRepository.save(updatedUser);
                    }
                });
    }
    
    /**
     * Deletes a user by their unique identifier.
     * 
     * @param id the ID of the user to delete
     * @return a {@link Mono} emitting {@code true} if user was deleted, {@code false} if not found
     */
    public Mono<Boolean> deleteUser(String id) {
        long startTime = System.currentTimeMillis();
        auditLogger.logMethodEntry(CLASS_NAME, "deleteUser", id);
        
        return userRepository.existsById(id)
                .flatMap(exists -> {
                    if (Boolean.TRUE.equals(exists)) {
                        return userRepository.deleteById(id).then(Mono.just(true));
                    } else {
                        return Mono.just(false);
                    }
                })
                .doOnNext(deleted -> {
                    if (Boolean.TRUE.equals(deleted)) {
                        auditLogger.logUserDeleted(id);
                    } else {
                        auditLogger.logUserDeleteFailed(id);
                    }
                    auditLogger.logMethodExit(CLASS_NAME, "deleteUser", System.currentTimeMillis() - startTime);
                });
    }
    
    /**
     * Checks if a user exists with the given ID.
     * 
     * @param id the user ID to check
     * @return a {@link Mono} emitting {@code true} if user exists, {@code false} otherwise
     */
    public Mono<Boolean> userExists(String id) {
        return userRepository.existsById(id);
    }
    
    /**
     * Checks if a user exists with the given email address.
     * 
     * @param email the email address to check
     * @return a {@link Mono} emitting {@code true} if user exists, {@code false} otherwise
     */
    public Mono<Boolean> emailExists(String email) {
        return userRepository.existsByEmail(email);
    }
    
    /**
     * Gets the total count of users.
     * 
     * @return a {@link Mono} emitting the total number of users
     */
    public Mono<Long> getUserCount() {
        return userRepository.count();
    }
    
    /**
     * Deletes all users from the repository.
     * 
     * <p><strong>Caution:</strong> This method removes all user data.
     * Use with extreme care, typically only in test environments.</p>
     * 
     * @return a {@link Mono} that completes when all users are deleted
     */
    public Mono<Void> deleteAllUsers() {
        return userRepository.deleteAll();
    }
}
