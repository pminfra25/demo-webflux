package com.example.demo.repository.impl;

import com.example.demo.model.User;
import com.example.demo.repository.UserRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;

/**
 * In-memory implementation of UserRepository for testing and development.
 * 
 * <p>This implementation uses a {@link ConcurrentHashMap} to store users in memory.
 * It's thread-safe and suitable for development, testing, and demonstration purposes.
 * For production use, consider implementing a database-backed repository using
 * R2DBC, MongoDB Reactive, or other reactive database technologies.</p>
 * 
 * <p>Key characteristics:</p>
 * <ul>
 *   <li>Thread-safe using ConcurrentHashMap</li>
 *   <li>Non-persistent (data is lost on application restart)</li>
 *   <li>Reactive using Mono and Flux publishers</li>
 *   <li>Suitable for testing and prototyping</li>
 * </ul>
 * 
 * @author Generated by GitHub Copilot
 * @version 1.0
 * @since 1.0
 */
@Repository
public class InMemoryUserRepository implements UserRepository {
    
    /** Thread-safe in-memory storage for users */
    private final Map<String, User> users = new ConcurrentHashMap<>();
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Mono<User> save(User user) {
        return Mono.fromCallable(() -> {
            users.put(user.getId(), user);
            return user;
        });
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Mono<User> findById(String id) {
        return Mono.fromCallable(() -> users.get(id))
                .filter(Objects::nonNull);
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Mono<User> findByEmail(String email) {
        return Flux.fromIterable(users.values())
                .filter(user -> email.equals(user.getEmail()))
                .next();
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Flux<User> findByFirstName(String firstName) {
        return Flux.fromIterable(users.values())
                .filter(user -> firstName.equals(user.getFirstName()));
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Flux<User> findByLastName(String lastName) {
        return Flux.fromIterable(users.values())
                .filter(user -> lastName.equals(user.getLastName()));
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Flux<User> findByNameContaining(String searchTerm) {
        String lowerSearchTerm = searchTerm.toLowerCase();
        return Flux.fromIterable(users.values())
                .filter(user -> 
                    user.getFirstName().toLowerCase().contains(lowerSearchTerm) ||
                    user.getLastName().toLowerCase().contains(lowerSearchTerm)
                );
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Flux<User> findAll() {
        return Flux.fromIterable(users.values());
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Mono<Void> deleteById(String id) {
        return Mono.fromRunnable(() -> users.remove(id));
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Mono<Void> delete(User user) {
        return deleteById(user.getId());
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Mono<Boolean> existsById(String id) {
        return Mono.fromCallable(() -> users.containsKey(id));
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Mono<Boolean> existsByEmail(String email) {
        return Flux.fromIterable(users.values())
                .any(user -> email.equals(user.getEmail()));
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Mono<Long> count() {
        return Mono.fromCallable(() -> (long) users.size());
    }
    
    /**
     * {@inheritDoc}
     */
    @Override
    public Mono<Void> deleteAll() {
        return Mono.fromRunnable(users::clear);
    }
    
    /**
     * Initializes the repository with some sample data for testing.
     * 
     * <p>This method adds a few sample users to help with development
     * and testing. In a real application, you might want to remove this
     * or move it to a separate data initialization component.</p>
     * 
     * @return a {@link Mono<Void>} that completes when initialization is done
     */
    public Mono<Void> initializeSampleData() {
        return Flux.just(
                new User("1", "John", "Doe", "john.doe@example.com"),
                new User("2", "Jane", "Smith", "jane.smith@example.com"),
                new User("3", "Alice", "Johnson", "alice.johnson@example.com"),
                new User("4", "Bob", "Brown", "bob.brown@example.com")
        )
        .flatMap(this::save)
        .then();
    }
}
